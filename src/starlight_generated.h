// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_STARLIGHT_NETWORK_H_
#define FLATBUFFERS_GENERATED_STARLIGHT_NETWORK_H_

#include "flatbuffers/flatbuffers.h"


namespace network {

struct ChunkPosition;
struct BlockPosition;
struct SimpleBlock;
struct TAG_End;
struct TAG_Byte;
struct TAG_Short;
struct TAG_Int;
struct TAG_Long;
struct TAG_Float;
struct TAG_Double;
struct TAG_Byte_Array;
struct TAG_String;
struct TAG_Compound;
struct TAG_Int_Array;
struct Tag;
struct ComplexBlock;
struct Chunk;
struct Packet;
struct Chat;

enum class Payload : uint8_t {
  NONE = 0,
  TAG_End = 1,
  TAG_Byte = 2,
  TAG_Short = 3,
  TAG_Int = 4,
  TAG_Long = 5,
  TAG_Float = 6,
  TAG_Double = 7,
  TAG_Byte_Array = 8,
  TAG_String = 9,
  TAG_Compound = 10,
  TAG_Int_Array = 11,
  MIN = NONE,
  MAX = TAG_Int_Array
};

inline const char **EnumNamesPayload() {
  static const char *names[] = { "NONE", "TAG_End", "TAG_Byte", "TAG_Short", "TAG_Int", "TAG_Long", "TAG_Float", "TAG_Double", "TAG_Byte_Array", "TAG_String", "TAG_Compound", "TAG_Int_Array", nullptr };
  return names;
}

inline const char *EnumNamePayload(Payload e) { return EnumNamesPayload()[static_cast<int>(e)]; }

inline bool VerifyPayload(flatbuffers::Verifier &verifier, const void *union_obj, Payload type);

enum class Message : uint8_t {
  NONE = 0,
  Chat = 1,
  MIN = NONE,
  MAX = Chat
};

inline const char **EnumNamesMessage() {
  static const char *names[] = { "NONE", "Chat", nullptr };
  return names;
}

inline const char *EnumNameMessage(Message e) { return EnumNamesMessage()[static_cast<int>(e)]; }

inline bool VerifyMessage(flatbuffers::Verifier &verifier, const void *union_obj, Message type);

MANUALLY_ALIGNED_STRUCT(4) ChunkPosition FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t z_;

 public:
  ChunkPosition(int32_t _x, int32_t _z)
    : x_(flatbuffers::EndianScalar(_x)), z_(flatbuffers::EndianScalar(_z)) { }

  int32_t x() const { return flatbuffers::EndianScalar(x_); }
  int32_t z() const { return flatbuffers::EndianScalar(z_); }
};
STRUCT_END(ChunkPosition, 8);

MANUALLY_ALIGNED_STRUCT(4) BlockPosition FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;
  int32_t z_;

 public:
  BlockPosition(int32_t _x, int32_t _y, int32_t _z)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)), z_(flatbuffers::EndianScalar(_z)) { }

  int32_t x() const { return flatbuffers::EndianScalar(x_); }
  int32_t y() const { return flatbuffers::EndianScalar(y_); }
  int32_t z() const { return flatbuffers::EndianScalar(z_); }
};
STRUCT_END(BlockPosition, 12);

MANUALLY_ALIGNED_STRUCT(2) SimpleBlock FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t type_;

 public:
  SimpleBlock(uint16_t _type)
    : type_(flatbuffers::EndianScalar(_type)) { }

  uint16_t type() const { return flatbuffers::EndianScalar(type_); }
};
STRUCT_END(SimpleBlock, 2);

struct TAG_End FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct TAG_EndBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  TAG_EndBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TAG_EndBuilder &operator=(const TAG_EndBuilder &);
  flatbuffers::Offset<TAG_End> Finish() {
    auto o = flatbuffers::Offset<TAG_End>(fbb_.EndTable(start_, 0));
    return o;
  }
};

inline flatbuffers::Offset<TAG_End> CreateTAG_End(flatbuffers::FlatBufferBuilder &_fbb) {
  TAG_EndBuilder builder_(_fbb);
  return builder_.Finish();
}

struct TAG_Byte FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  int8_t value() const { return GetField<int8_t>(VT_VALUE, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct TAG_ByteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int8_t value) { fbb_.AddElement<int8_t>(TAG_Byte::VT_VALUE, value, 0); }
  TAG_ByteBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TAG_ByteBuilder &operator=(const TAG_ByteBuilder &);
  flatbuffers::Offset<TAG_Byte> Finish() {
    auto o = flatbuffers::Offset<TAG_Byte>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<TAG_Byte> CreateTAG_Byte(flatbuffers::FlatBufferBuilder &_fbb,
   int8_t value = 0) {
  TAG_ByteBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct TAG_Short FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  int16_t value() const { return GetField<int16_t>(VT_VALUE, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct TAG_ShortBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int16_t value) { fbb_.AddElement<int16_t>(TAG_Short::VT_VALUE, value, 0); }
  TAG_ShortBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TAG_ShortBuilder &operator=(const TAG_ShortBuilder &);
  flatbuffers::Offset<TAG_Short> Finish() {
    auto o = flatbuffers::Offset<TAG_Short>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<TAG_Short> CreateTAG_Short(flatbuffers::FlatBufferBuilder &_fbb,
   int16_t value = 0) {
  TAG_ShortBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct TAG_Int FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  int32_t value() const { return GetField<int32_t>(VT_VALUE, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct TAG_IntBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int32_t value) { fbb_.AddElement<int32_t>(TAG_Int::VT_VALUE, value, 0); }
  TAG_IntBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TAG_IntBuilder &operator=(const TAG_IntBuilder &);
  flatbuffers::Offset<TAG_Int> Finish() {
    auto o = flatbuffers::Offset<TAG_Int>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<TAG_Int> CreateTAG_Int(flatbuffers::FlatBufferBuilder &_fbb,
   int32_t value = 0) {
  TAG_IntBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct TAG_Long FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  int64_t value() const { return GetField<int64_t>(VT_VALUE, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct TAG_LongBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int64_t value) { fbb_.AddElement<int64_t>(TAG_Long::VT_VALUE, value, 0); }
  TAG_LongBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TAG_LongBuilder &operator=(const TAG_LongBuilder &);
  flatbuffers::Offset<TAG_Long> Finish() {
    auto o = flatbuffers::Offset<TAG_Long>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<TAG_Long> CreateTAG_Long(flatbuffers::FlatBufferBuilder &_fbb,
   int64_t value = 0) {
  TAG_LongBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct TAG_Float FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  float value() const { return GetField<float>(VT_VALUE, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct TAG_FloatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(float value) { fbb_.AddElement<float>(TAG_Float::VT_VALUE, value, 0); }
  TAG_FloatBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TAG_FloatBuilder &operator=(const TAG_FloatBuilder &);
  flatbuffers::Offset<TAG_Float> Finish() {
    auto o = flatbuffers::Offset<TAG_Float>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<TAG_Float> CreateTAG_Float(flatbuffers::FlatBufferBuilder &_fbb,
   float value = 0) {
  TAG_FloatBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct TAG_Double FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  double value() const { return GetField<double>(VT_VALUE, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct TAG_DoubleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(double value) { fbb_.AddElement<double>(TAG_Double::VT_VALUE, value, 0); }
  TAG_DoubleBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TAG_DoubleBuilder &operator=(const TAG_DoubleBuilder &);
  flatbuffers::Offset<TAG_Double> Finish() {
    auto o = flatbuffers::Offset<TAG_Double>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<TAG_Double> CreateTAG_Double(flatbuffers::FlatBufferBuilder &_fbb,
   double value = 0) {
  TAG_DoubleBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct TAG_Byte_Array FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<int8_t> *value() const { return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_VALUE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct TAG_Byte_ArrayBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<int8_t>> value) { fbb_.AddOffset(TAG_Byte_Array::VT_VALUE, value); }
  TAG_Byte_ArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TAG_Byte_ArrayBuilder &operator=(const TAG_Byte_ArrayBuilder &);
  flatbuffers::Offset<TAG_Byte_Array> Finish() {
    auto o = flatbuffers::Offset<TAG_Byte_Array>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<TAG_Byte_Array> CreateTAG_Byte_Array(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<int8_t>> value = 0) {
  TAG_Byte_ArrayBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct TAG_String FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::String *value() const { return GetPointer<const flatbuffers::String *>(VT_VALUE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct TAG_StringBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::String> value) { fbb_.AddOffset(TAG_String::VT_VALUE, value); }
  TAG_StringBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TAG_StringBuilder &operator=(const TAG_StringBuilder &);
  flatbuffers::Offset<TAG_String> Finish() {
    auto o = flatbuffers::Offset<TAG_String>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<TAG_String> CreateTAG_String(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> value = 0) {
  TAG_StringBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct TAG_Compound FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Tag>> *value() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Tag>> *>(VT_VALUE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.VerifyVectorOfTables(value()) &&
           verifier.EndTable();
  }
};

struct TAG_CompoundBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tag>>> value) { fbb_.AddOffset(TAG_Compound::VT_VALUE, value); }
  TAG_CompoundBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TAG_CompoundBuilder &operator=(const TAG_CompoundBuilder &);
  flatbuffers::Offset<TAG_Compound> Finish() {
    auto o = flatbuffers::Offset<TAG_Compound>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<TAG_Compound> CreateTAG_Compound(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tag>>> value = 0) {
  TAG_CompoundBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct TAG_Int_Array FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<int32_t> *value() const { return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_VALUE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct TAG_Int_ArrayBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<int32_t>> value) { fbb_.AddOffset(TAG_Int_Array::VT_VALUE, value); }
  TAG_Int_ArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TAG_Int_ArrayBuilder &operator=(const TAG_Int_ArrayBuilder &);
  flatbuffers::Offset<TAG_Int_Array> Finish() {
    auto o = flatbuffers::Offset<TAG_Int_Array>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<TAG_Int_Array> CreateTAG_Int_Array(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<int32_t>> value = 0) {
  TAG_Int_ArrayBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Tag FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_PAYLOAD_TYPE = 6,
    VT_PAYLOAD = 8
  };
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  Payload payload_type() const { return static_cast<Payload>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0)); }
  const void *payload() const { return GetPointer<const void *>(VT_PAYLOAD); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PAYLOAD) &&
           VerifyPayload(verifier, payload(), payload_type()) &&
           verifier.EndTable();
  }
};

struct TagBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(Tag::VT_NAME, name); }
  void add_payload_type(Payload payload_type) { fbb_.AddElement<uint8_t>(Tag::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0); }
  void add_payload(flatbuffers::Offset<void> payload) { fbb_.AddOffset(Tag::VT_PAYLOAD, payload); }
  TagBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TagBuilder &operator=(const TagBuilder &);
  flatbuffers::Offset<Tag> Finish() {
    auto o = flatbuffers::Offset<Tag>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<Tag> CreateTag(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   Payload payload_type = Payload::NONE,
   flatbuffers::Offset<void> payload = 0) {
  TagBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_name(name);
  builder_.add_payload_type(payload_type);
  return builder_.Finish();
}

struct ComplexBlock FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_POSITION = 6,
    VT_TAGS = 8
  };
  uint16_t type() const { return GetField<uint16_t>(VT_TYPE, 0); }
  const BlockPosition *position() const { return GetStruct<const BlockPosition *>(VT_POSITION); }
  const flatbuffers::Vector<flatbuffers::Offset<Tag>> *tags() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Tag>> *>(VT_TAGS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_TYPE) &&
           VerifyField<BlockPosition>(verifier, VT_POSITION) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TAGS) &&
           verifier.Verify(tags()) &&
           verifier.VerifyVectorOfTables(tags()) &&
           verifier.EndTable();
  }
};

struct ComplexBlockBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(uint16_t type) { fbb_.AddElement<uint16_t>(ComplexBlock::VT_TYPE, type, 0); }
  void add_position(const BlockPosition *position) { fbb_.AddStruct(ComplexBlock::VT_POSITION, position); }
  void add_tags(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tag>>> tags) { fbb_.AddOffset(ComplexBlock::VT_TAGS, tags); }
  ComplexBlockBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ComplexBlockBuilder &operator=(const ComplexBlockBuilder &);
  flatbuffers::Offset<ComplexBlock> Finish() {
    auto o = flatbuffers::Offset<ComplexBlock>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<ComplexBlock> CreateComplexBlock(flatbuffers::FlatBufferBuilder &_fbb,
   uint16_t type = 0,
   const BlockPosition *position = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tag>>> tags = 0) {
  ComplexBlockBuilder builder_(_fbb);
  builder_.add_tags(tags);
  builder_.add_position(position);
  builder_.add_type(type);
  return builder_.Finish();
}

struct Chunk FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_POSITION = 4,
    VT_SIMPLEBLOCKS = 6,
    VT_COMPLEXBLOCKS = 8
  };
  const ChunkPosition *position() const { return GetStruct<const ChunkPosition *>(VT_POSITION); }
  const flatbuffers::Vector<const SimpleBlock *> *simpleBlocks() const { return GetPointer<const flatbuffers::Vector<const SimpleBlock *> *>(VT_SIMPLEBLOCKS); }
  const flatbuffers::Vector<flatbuffers::Offset<ComplexBlock>> *complexBlocks() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ComplexBlock>> *>(VT_COMPLEXBLOCKS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<ChunkPosition>(verifier, VT_POSITION) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_SIMPLEBLOCKS) &&
           verifier.Verify(simpleBlocks()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_COMPLEXBLOCKS) &&
           verifier.Verify(complexBlocks()) &&
           verifier.VerifyVectorOfTables(complexBlocks()) &&
           verifier.EndTable();
  }
};

struct ChunkBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(const ChunkPosition *position) { fbb_.AddStruct(Chunk::VT_POSITION, position); }
  void add_simpleBlocks(flatbuffers::Offset<flatbuffers::Vector<const SimpleBlock *>> simpleBlocks) { fbb_.AddOffset(Chunk::VT_SIMPLEBLOCKS, simpleBlocks); }
  void add_complexBlocks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ComplexBlock>>> complexBlocks) { fbb_.AddOffset(Chunk::VT_COMPLEXBLOCKS, complexBlocks); }
  ChunkBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ChunkBuilder &operator=(const ChunkBuilder &);
  flatbuffers::Offset<Chunk> Finish() {
    auto o = flatbuffers::Offset<Chunk>(fbb_.EndTable(start_, 3));
    fbb_.Required(o, Chunk::VT_POSITION);  // position
    fbb_.Required(o, Chunk::VT_SIMPLEBLOCKS);  // simpleBlocks
    return o;
  }
};

inline flatbuffers::Offset<Chunk> CreateChunk(flatbuffers::FlatBufferBuilder &_fbb,
   const ChunkPosition *position = 0,
   flatbuffers::Offset<flatbuffers::Vector<const SimpleBlock *>> simpleBlocks = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ComplexBlock>>> complexBlocks = 0) {
  ChunkBuilder builder_(_fbb);
  builder_.add_complexBlocks(complexBlocks);
  builder_.add_simpleBlocks(simpleBlocks);
  builder_.add_position(position);
  return builder_.Finish();
}

struct Packet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  Message message_type() const { return static_cast<Message>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0)); }
  const void *message() const { return GetPointer<const void *>(VT_MESSAGE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MESSAGE) &&
           VerifyMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

struct PacketBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(Message message_type) { fbb_.AddElement<uint8_t>(Packet::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0); }
  void add_message(flatbuffers::Offset<void> message) { fbb_.AddOffset(Packet::VT_MESSAGE, message); }
  PacketBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PacketBuilder &operator=(const PacketBuilder &);
  flatbuffers::Offset<Packet> Finish() {
    auto o = flatbuffers::Offset<Packet>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<Packet> CreatePacket(flatbuffers::FlatBufferBuilder &_fbb,
   Message message_type = Message::NONE,
   flatbuffers::Offset<void> message = 0) {
  PacketBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

struct Chat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MESSAGE = 4
  };
  const flatbuffers::String *message() const { return GetPointer<const flatbuffers::String *>(VT_MESSAGE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MESSAGE) &&
           verifier.Verify(message()) &&
           verifier.EndTable();
  }
};

struct ChatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message(flatbuffers::Offset<flatbuffers::String> message) { fbb_.AddOffset(Chat::VT_MESSAGE, message); }
  ChatBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ChatBuilder &operator=(const ChatBuilder &);
  flatbuffers::Offset<Chat> Finish() {
    auto o = flatbuffers::Offset<Chat>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<Chat> CreateChat(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> message = 0) {
  ChatBuilder builder_(_fbb);
  builder_.add_message(message);
  return builder_.Finish();
}

inline bool VerifyPayload(flatbuffers::Verifier &verifier, const void *union_obj, Payload type) {
  switch (type) {
    case Payload::NONE: return true;
    case Payload::TAG_End: return verifier.VerifyTable(reinterpret_cast<const TAG_End *>(union_obj));
    case Payload::TAG_Byte: return verifier.VerifyTable(reinterpret_cast<const TAG_Byte *>(union_obj));
    case Payload::TAG_Short: return verifier.VerifyTable(reinterpret_cast<const TAG_Short *>(union_obj));
    case Payload::TAG_Int: return verifier.VerifyTable(reinterpret_cast<const TAG_Int *>(union_obj));
    case Payload::TAG_Long: return verifier.VerifyTable(reinterpret_cast<const TAG_Long *>(union_obj));
    case Payload::TAG_Float: return verifier.VerifyTable(reinterpret_cast<const TAG_Float *>(union_obj));
    case Payload::TAG_Double: return verifier.VerifyTable(reinterpret_cast<const TAG_Double *>(union_obj));
    case Payload::TAG_Byte_Array: return verifier.VerifyTable(reinterpret_cast<const TAG_Byte_Array *>(union_obj));
    case Payload::TAG_String: return verifier.VerifyTable(reinterpret_cast<const TAG_String *>(union_obj));
    case Payload::TAG_Compound: return verifier.VerifyTable(reinterpret_cast<const TAG_Compound *>(union_obj));
    case Payload::TAG_Int_Array: return verifier.VerifyTable(reinterpret_cast<const TAG_Int_Array *>(union_obj));
    default: return false;
  }
}

inline bool VerifyMessage(flatbuffers::Verifier &verifier, const void *union_obj, Message type) {
  switch (type) {
    case Message::NONE: return true;
    case Message::Chat: return verifier.VerifyTable(reinterpret_cast<const Chat *>(union_obj));
    default: return false;
  }
}

inline const network::Packet *GetPacket(const void *buf) { return flatbuffers::GetRoot<network::Packet>(buf); }

inline bool VerifyPacketBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<network::Packet>(); }

inline void FinishPacketBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<network::Packet> root) { fbb.Finish(root); }

}  // namespace network

#endif  // FLATBUFFERS_GENERATED_STARLIGHT_NETWORK_H_
